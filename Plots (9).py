import numpy as np
import matplotlib.pyplot as plt
import kernel as ker

# Update font settings
plt.rcParams.update({
    'font.size': 16,
    'pdf.fonttype': 42,
    'font.sans-serif': 'Arial'
})

# ------------------ Figure Generation --------------------- #

#### These functions make the figures 4C, 5C, 6B, 8

"""
PLOT 4C
---- the dataset 4C is generated by the function midway_zero_cube in kernel, ran on many nodes and concatenated
"""

def plot_4C(filename='4c'):
    Acube = np.load('data_4C.npy')
    cm = plt.cm.get_cmap('binary')
    Acube[:, 2] = np.log(1 / Acube[:, 2])  # now its amax/amin
    Acube[:, 0] *= 20  # multiple t1 by 20 to be in units of kernel decay timescale
    Acube[:, 1] *= 20  # same with t2

    b = .5
    normalize = plt.Normalize(vmin=min(np.log10(Acube[:, 0])) - b, vmax=max(np.log10(Acube[:, 0])) + b)
    plt.scatter(np.log(Acube[:, 1] / Acube[:, 0]), Acube[:, 2], s=30, c=np.log10(Acube[:, 0]), norm=normalize, cmap=cm)
    ticks = np.linspace(min(np.log10(Acube[:, 0])) - b, max(np.log10(Acube[:, 0])) + b, 5, endpoint=True)
    plt.xlabel('ln(t2/t1)')
    plt.ylabel('ln(Amax/Amin)')
    plt.xlim(0, 6)
    plt.title('FIGURE 4C:  AUC = average val = 0')
    cbar = plt.colorbar(plt.cm.ScalarMappable(norm=normalize, cmap=cm), ticks=ticks)
    cbar.set_label('log10 t1/t_k', rotation=270, fontsize=15)
    plt.show()

""" PLOT 5C:
    ------ the dataset data_5C.npy was generated by the function midway_expanded_Amax_f3_p2_cube in kernel
"""
def plot_5C(filename='5c'):
    Acube = np.load('data_5C.npy')
    cm = plt.cm.get_cmap('binary')
    Acube[:, 2] = np.log(1 / Acube[:, 2])  # now its amax/amin
    Acube[:, 0] *= 20  # multiple t1 by 20 to be in units of kernel decay timescale
    Acube[:, 1] *= 20  # same with t2

    indices = [i for i, x in enumerate(Acube[:, 3]) if (x == 12 or x < 0)]
    Acube[indices, :] = None

    indices = [x for x in range(len(Acube[:, 2])) if Acube[x, 3] <= 0 or Acube[x, 3] > 0.5]
    Acube[indices, :] = None

    Acube[:, 2] = Acube[:, 1] + Acube[:, 0]
    b = 100
    normalize = plt.Normalize(vmin=min(Acube[:, 2]) - b, vmax=max(Acube[:, 2]) + b)
    plt.scatter(Acube[:, 0], Acube[:, 3], s=30, c=Acube[:, 2], norm=normalize, cmap=cm)
    plt.xlabel('(t1)/t_k')
    plt.ylabel('y_int/Amax')
    plt.title('FIGURE 5C: AUC = 0.05, average val = 25')
    cbar = plt.colorbar(plt.cm.ScalarMappable(norm=normalize, cmap=cm))
    cbar.set_label('t1+t2/t_k', rotation=270, fontsize=15)
    plt.show()

"""
PLOT 6B:
 ----- the curves are generated with function midway_f3p4_v5 in kernel
 ----- the error metrics are generated with function f4_error_analysis in kernel
"""

def plot_6B(filename='6b'):
    data = np.load('data_6B.npy', allow_pickle=True)
    error_data = np.load('6B_stats.npy', allow_pickle=True)

    b = 0.5
    RF_list = []
    for x in range(100):
        for y in range(50):
            RF_list.append(data[x][y][4])
    plt.scatter(error_data[:, 2], [np.log(abs(x / 10)) for x in error_data[:, 1]], s=5)
    plt.xlabel('Dissipation = f(gamma)')
    plt.ylabel('ln(abs(offset/av))')
    plt.title('offset vs dissipation in Markov kernel response, color = Aminrat')
    plt.xlim(1, 10)
    plt.ylim(-5, -2)
    plt.show()

""" FIGURE 8
 - timescale vs error
"""

def plot_F8(filename='f8'):
    ker.Sim.kernel = ker.Sim._initialize_uneven_ecoli_kernel(0)
    times = []
    weight_updates = []
    A = 20
    t2 = 20
    for t in np.linspace(0.01, 8, 79):
        p1 = A / t2
        p2 = A / t
        theta = (p1 + p2) / 2
        update = (ker.Sim.compute_period_weight_update(-10, 10, t, t2, theta, nonlinearity_style="linear_threshold",
                                                      downswing='yes'))
        update /= 20
        weight_updates.append(update)
        t = (20 * t)
        times.append(t)
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.scatter(times, weight_updates, color='black')
    ax.plot(times, weight_updates, color='black')
    ax.set_xlabel('tau_1/B', fontsize=15)
    ax.set_ylabel('weight_update / Signal Amplitude', fontsize=15)
    ax.set_ylim(0, 1)
    plt.tight_layout()
    plt.show()

# Call functions to generate plots
plot_4C()
plot_5C()
plot_6B()
plot_F8()